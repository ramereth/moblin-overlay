diff -urN a/src/audio-manager-dbus-generic-service.c b/src/audio-manager-dbus-generic-service.c
--- a/src/audio-manager-dbus-generic-service.c	2009-05-11 06:08:18.000000000 +0800
+++ b/src/audio-manager-dbus-generic-service.c	2009-07-23 11:20:45.000000000 +0800
@@ -124,7 +124,7 @@
 
     dbus_error_init(&error);
 
-    pa_log_debug("dbus: interface=%s, path=%s, member=%s\n",
+    pa_log_warn("dbus: interface=%s, path=%s, member=%s\n",
                  dbus_message_get_interface(message),
                  dbus_message_get_path(message),
                  dbus_message_get_member(message));
diff -urN a/src/audio-manager-dbus-server-util.c b/src/audio-manager-dbus-server-util.c
--- a/src/audio-manager-dbus-server-util.c	2009-05-11 06:08:18.000000000 +0800
+++ b/src/audio-manager-dbus-server-util.c	2009-07-23 11:20:45.000000000 +0800
@@ -143,16 +143,21 @@
             dbus_message_iter_close_container(&iter, &iter_array);
         }
         else if (method->handler_return_type == AM_INTV) {
+            guint len;
+            guint i;
             uint_values = return_value;
 
-            dbus_message_iter_init_append(result, &iter);
-            dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, 
-                                        DBUS_TYPE_UINT32_AS_STRING, &iter_array);
-            while (*uint_values != 0) {
-                dbus_message_iter_append_basic(&iter_array, DBUS_TYPE_UINT32, uint_values);
-                uint_values++;
+            //dbus_message_iter_init_append(result, &iter);
+            //dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, 
+            //                            DBUS_TYPE_UINT32_AS_STRING, &iter_array);
+
+            len = *uint_values;
+            uint_values ++;
+            for (i = 0; i < len; i+=2) {
+                dbus_message_append_args(result, uint_values[0], uint_values+1, DBUS_TYPE_INVALID);
+                uint_values +=2;
             }
-            dbus_message_iter_close_container(&iter, &iter_array);
+            //dbus_message_iter_close_container(&iter, &iter_array);
         }
         else
             dbus_message_append_args(result, method->handler_return_type, &return_value, DBUS_TYPE_INVALID);
@@ -161,6 +166,8 @@
     dbus_connection_send(connection, result, 0);
     dbus_connection_flush(connection);
     dbus_message_unref(result);
+    if (method->handler_return_type == AM_INTV || method->handler_return_type == AM_STRV)
+      g_free(return_value);
     
     //g_free(path);
     //g_free(method_name);
diff -urN a/src/audiomanager-stream.c b/src/audiomanager-stream.c
--- a/src/audiomanager-stream.c	2009-05-11 10:48:09.000000000 +0800
+++ b/src/audiomanager-stream.c	2009-07-23 11:20:45.000000000 +0800
@@ -41,7 +41,7 @@
 #include "audiomanager-stream.h"
 #include "extend-protocol.h"
 
-#define SAVE_VOLUME_OR_NOT TRUE
+#define SAVE_VOLUME_OR_NOT FALSE
 #define ABSOLUTE_VOLUME_OR_NOT TRUE
 
 static void inherit_property_from_app(am_app *a, am_stream *s) {
@@ -62,8 +62,12 @@
 
 static int map_mediarole_to_prio(am_core* c, const char* role) {
     int* prio = NULL;
+
     pa_assert(c);
-    pa_assert(role);
+
+    if ( !role )
+        role = "music";
+
     prio = (int *)pa_hashmap_get(c->prio_mapping, role);
     if ( prio )
         return *prio;
@@ -80,7 +84,9 @@
 }
 
 static am_conf_action convert_obj_action_to_int(char *action) {
-    pa_assert(action);
+
+    if ( !action )
+        return DO_PAUSE;
 
     if ( !strcmp(action, "pause") )
         return DO_PAUSE;
@@ -302,6 +308,7 @@
     if (gain < 0)
         gain = AM_VOLUME_NORMAL;
     linear = ((double) gain)/AM_VOLUME_NORMAL;
+    pa_log_debug("am_default_set_volume to gain %d %f\n", gain, linear);
 
     vol = pa_sw_volume_from_linear(linear);
 
diff -urN a/src/module-audiomanager.c b/src/module-audiomanager.c
--- a/src/module-audiomanager.c	2009-05-12 12:36:56.000000000 +0800
+++ b/src/module-audiomanager.c	2009-07-23 11:20:45.000000000 +0800
@@ -282,10 +282,10 @@
 
     switch ( code ) {
         case AM_APP_NEW:
-            pa_log_debug("Get Msg(AM_APP_NEW)\n");
+            pa_log_warn("Get Msg(AM_APP_NEW)\n");
             break;
         case AM_APP_TERMINATE:
-            pa_log_debug("Get Msg(AM_APP_TERMINATE)\n");
+            pa_log_warn("Get Msg(AM_APP_TERMINATE)\n");
             break;
         case AM_STREAM_INPUT_NEW:
             {
@@ -293,7 +293,7 @@
                 pa_assert(c->policy_engine);
                 c->policy_engine(c, (void *)s, AM_STREAM_INPUT_NEW_EVENT);
                 dump_q(c);
-                pa_log_debug("Get Msg(AM_STREAM_INPUT_NEW) name:%s\n", s->name);
+                pa_log_warn("Get Msg(AM_STREAM_INPUT_NEW) name:%s\n", s->name);
                 break;
             }
         case AM_STREAM_INPUT_TERMINATE:
@@ -302,18 +302,18 @@
                 pa_assert(s);
                 pa_assert( STREAM_IS_SINK_INPUT(s) );
 
-                pa_log_debug("Get Msg(AM_STREAM_INPUT_TERMINATE)\n");
+                pa_log_warn("Get Msg(AM_STREAM_INPUT_TERMINATE)\n");
                 c->policy_engine(c, (void *)s, AM_STREAM_INPUT_TERMINATE_EVENT);
                 break;
             }
         case AM_STREAM_OUTPUT_NEW:
-            pa_log_debug("Get Msg(AM_STREAM_OUTPUT_NEW)\n");
+            pa_log_warn("Get Msg(AM_STREAM_OUTPUT_NEW)\n");
             break;
         case AM_STREAM_OUTPUT_TERMINATE:
             {
                 am_stream *s = (am_stream *)data;
                 pa_assert( STREAM_IS_SOURCE_OUTPUT(s) );
-                pa_log_debug("Get Msg(AM_STREAM_OUTPUT_TERMINATE)\n");
+                pa_log_warn("Get Msg(AM_STREAM_OUTPUT_TERMINATE)\n");
                 break;
             }
         case AM_STREAM_STATE_CHANGE:
@@ -342,7 +342,7 @@
                     pa_assert(c->policy_engine);
                     c->policy_engine(c, (void *)s, AM_STREAM_INPUT_RESUME_EVENT);
                 } else
-                    pa_log_debug("AM_STREAM_STATE_CHANGE(state = %d) unhandled\n", i->state);
+                    pa_log_warn("AM_STREAM_STATE_CHANGE(state = %d) unhandled\n", i->state);
                 break;
             }
         case AM_AVAIL_DEVICE_UPDATE:
@@ -351,7 +351,7 @@
             }
         case AM_DEVICE_NEW_LIST:
             {
-                pa_log_debug("get new device list\n");
+                pa_log_warn("get new device list\n");
                 dump_devices(c);
                 break;
             }
@@ -391,7 +391,7 @@
     pa_asyncmsgq_post(c->thread_mq.outq, PA_MSGOBJECT(c->module->core), PA_CORE_MESSAGE_UNLOAD_MODULE, c->module, 0, NULL, NULL);
     pa_asyncmsgq_wait_for(c->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
 finish:
-    pa_log_debug("Thread shutting down");
+    pa_log_warn("Thread shutting down");
 }
 
 static void reset_core_callbacks(am_core *c) {
@@ -606,5 +606,5 @@
 
     pa_xfree(c);
 
-    pa_log_debug("Module-audiomanager unload!\n");
+    pa_log_warn("Module-audiomanager unload!\n");
 }
diff -urN a/src/platform/mrst/audio-manager-dbus-mrst-service.c b/src/platform/mrst/audio-manager-dbus-mrst-service.c
--- a/src/platform/mrst/audio-manager-dbus-mrst-service.c	2009-05-11 06:08:18.000000000 +0800
+++ b/src/platform/mrst/audio-manager-dbus-mrst-service.c	2009-07-23 11:20:45.000000000 +0800
@@ -39,12 +39,27 @@
 #include "audio-manager-dbus-mrst-service.h"
 #include "audiomanager.h"
 #include "module-mrst-specific.h"
+#include "modem_agent.h"
+
 /* private static members */
 AM_METHOD_DEFINE(am_dbus_server_handle_lpe_register);
 AM_METHOD_DEFINE(am_dbus_server_handle_lpe_unregister);
 AM_METHOD_DEFINE(am_dbus_server_handle_lpe_stream_notify_pause);
 AM_METHOD_DEFINE(am_dbus_server_handle_lpe_stream_notify_resume);
 
+AM_METHOD_DEFINE(am_dbus_server_handle_register_modem_control_cb);
+AM_METHOD_DEFINE(am_dbus_server_handle_unregister_modem_control_cb);
+AM_METHOD_DEFINE(am_dbus_server_handle_request_modem_audio);
+AM_METHOD_DEFINE(am_dbus_server_handle_release_modem_audio);
+AM_METHOD_DEFINE(am_dbus_server_handle_modem_audio_set_dest);
+AM_METHOD_DEFINE(am_dbus_server_handle_modem_audio_get_dest);
+AM_METHOD_DEFINE(am_dbus_server_handle_modem_audio_set_mute);
+AM_METHOD_DEFINE(am_dbus_server_handle_modem_audio_get_mute);
+AM_METHOD_DEFINE(am_dbus_server_handle_set_gain);
+AM_METHOD_DEFINE(am_dbus_server_handle_get_gain);
+//AM_METHOD_DEFINE(am_dbus_server_handle_audio_changed);
+//AM_METHOD_DEFINE(am_dbus_server_handle_modem_audio_response);
+
 am_dbus_path_method_table_t am_lpe_method_table [] = {
 	{"LPEStreamRegister",              DBUS_TYPE_INT32,  am_dbus_server_handle_lpe_register},
 	{"LPEStreamUnregister",            DBUS_TYPE_INT32,  am_dbus_server_handle_lpe_unregister},
@@ -53,6 +68,23 @@
 	{ NULL, 0, NULL }
 };
 
+am_dbus_path_method_table_t am_3g_method_table [] = {
+	{"RegisterModemControlCb",  DBUS_TYPE_INT32,  am_dbus_server_handle_register_modem_control_cb},
+	{"UnregisterModemControlCb",  DBUS_TYPE_INT32,  am_dbus_server_handle_unregister_modem_control_cb},
+	{"RequestModemAudio",     DBUS_TYPE_INT32,  am_dbus_server_handle_request_modem_audio},
+	{"ReleaseModemAudio",     DBUS_TYPE_INT32,  am_dbus_server_handle_release_modem_audio},
+	{"ModemAudioSetDest",    DBUS_TYPE_INT32,  am_dbus_server_handle_modem_audio_set_dest},
+	{"ModemAudioGetDest",    AM_INTV,  am_dbus_server_handle_modem_audio_get_dest},
+	{"ModemAudioSetMute",    DBUS_TYPE_INT32,  am_dbus_server_handle_modem_audio_set_mute},
+	{"ModemAudioGetMute",    AM_INTV,  am_dbus_server_handle_modem_audio_get_mute},
+	{"ModemSetGain",    DBUS_TYPE_INT32,  am_dbus_server_handle_set_gain},
+  {"ModemGetGain",    DBUS_TYPE_INT32,  am_dbus_server_handle_get_gain},
+	//{"ModemAudioChanged",    DBUS_TYPE_INT32,  am_dbus_server_handle_audio_changed},
+	//{"ModemAudioResponse",    DBUS_TYPE_INT32,  am_dbus_server_handle_modem_audio_response},
+	{ NULL, 0, NULL }
+};
+
+
 /* This function handlers am_register */
 static void am_dbus_server_handle_lpe_register(am_dbus_server_t *server, DBusMessage *message, void **method_result) {
 
@@ -132,4 +164,201 @@
 	*method_result = (gpointer) value;
 }
 
+//----------3G Service ------------------------
+/* This function handlers am_register */
+static void am_dbus_server_handle_register_modem_control_cb(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+	DBusError err;
+	gint ret;
+	gchar *service, *path, *interface, *method;
+
+  service = path = interface = method = NULL;
+
+	dbus_error_init(&err);
+	ret = dbus_message_get_args(message, &err, DBUS_TYPE_STRING, &service,
+                                            DBUS_TYPE_STRING, &path,
+                                           DBUS_TYPE_STRING, &interface,
+                                          DBUS_TYPE_STRING, &method,
+                                          DBUS_TYPE_INVALID);
+	if (ret) {
+    value  = am_register_modem_control_cb(service, path, interface, method);
+  } else if (dbus_error_is_set(&err)) {
+		pa_log_error("am_dbus_server_handle_register_modem_control_cb:%s\n", err.message);
+    dbus_error_free(&err);
+  }
+
+	*method_result = (gpointer) value;
+
+  g_print("service:%s, path:%s, interface:%s, method:%s\n", service, path, interface, method);
+
+}
+
+static void am_dbus_server_handle_unregister_modem_control_cb(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+  value = am_unregister_modem_control_cb();
+	*method_result = (gpointer) value;
+}
+
+
+static void am_dbus_server_handle_request_modem_audio(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+	DBusError err;
+	gint ret;
+  guint request_id;
+
+	dbus_error_init(&err);
+	ret = dbus_message_get_args(message, &err, DBUS_TYPE_UINT32, &request_id,
+                                          DBUS_TYPE_INVALID);
+	if (ret) {
+    value  = am_request_modem_audio(request_id);
+  } else if (dbus_error_is_set(&err)) {
+		pa_log_error("am_dbus_server_handle_request_modem_audio:%s\n", err.message);
+    dbus_error_free(&err);
+  }
+
+	*method_result = (gpointer) value;
+}
+
+
+static void am_dbus_server_handle_release_modem_audio(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+	DBusError err;
+	gint ret;
+  guint request_id;
+
+	dbus_error_init(&err);
+	ret = dbus_message_get_args(message, &err, DBUS_TYPE_UINT32, &request_id,
+                                          DBUS_TYPE_INVALID);
+	if (ret) {
+    value  = am_release_modem_audio(request_id);
+  } else if (dbus_error_is_set(&err)) {
+		pa_log_error("am_dbus_server_handle_release_modem_audio:%s\n", err.message);
+    dbus_error_free(&err);
+  }
+
+	*method_result = (gpointer) value;
+}
+
+
+
+static void am_dbus_server_handle_modem_audio_set_dest(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+	DBusError err;
+	gint ret;
+  gint dest;
+
+	dbus_error_init(&err);
+	ret = dbus_message_get_args(message, &err, DBUS_TYPE_INT32, &dest,
+                                          DBUS_TYPE_INVALID);
+	if (ret) {
+    value  = am_modem_audio_set_dest(dest);
+  } else if (dbus_error_is_set(&err)) {
+		pa_log_error("am_dbus_server_handle_modem_audio_set_dest:%s\n", err.message);
+    dbus_error_free(&err);
+  }
+
+	*method_result = (gpointer) value;
+}
+
+static void am_dbus_server_handle_modem_audio_get_dest(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+  gint dest;
+  gint *arr;
+
+  value  = am_modem_audio_get_dest(&dest);
+
+  arr = g_malloc(5*sizeof(gint));
+  if (arr) {
+    arr[0] = 4;
+    arr[1] = DBUS_TYPE_INT32;
+    arr[2] = dest;
+    arr[3] = DBUS_TYPE_INT32;
+    arr[4] = value;
+  }
+
+	*method_result = (gpointer) arr;  /* TODO: free the arr in dbus-utils */
+}
+
+static void am_dbus_server_handle_modem_audio_set_mute(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+  DBusError err;
+  gint ret;
+  gboolean mute;
+
+  dbus_error_init(&err);
+  ret = dbus_message_get_args(message, &err, DBUS_TYPE_BOOLEAN, &mute,
+      DBUS_TYPE_INVALID);
+  if (ret) {
+    value  = am_modem_audio_set_mute(mute);
+  } else if (dbus_error_is_set(&err)) {
+    pa_log_error("am_dbus_server_handle_modem_audio_set_mute:%s\n", err.message);
+    dbus_error_free(&err);
+  }
+
+  *method_result = (gpointer) value;
+}
+
+static void am_dbus_server_handle_modem_audio_get_mute(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+  gboolean mute;
+  gint *arr;
+
+  value =  am_modem_audio_get_mute(&mute);
+  g_print("am_dbus_server_handle_modem_audio_get_mute: mute:%d\n", mute);
+  arr = g_malloc(5*sizeof(gint));
+  if (arr) {
+    arr[0] = 4; /* number of following integers */
+    arr[1] = DBUS_TYPE_BOOLEAN;
+    arr[2] = mute;
+    arr[3] = DBUS_TYPE_INT32;
+    arr[4] = value;
+  }
+
+	*method_result = (gpointer) arr;  /* TODO: free the arr in dbus-utils */
+}
+
+static void am_dbus_server_handle_set_gain(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+  DBusError err;
+  gint ret;
+  gint gain;
+
+  dbus_error_init(&err);
+  ret = dbus_message_get_args(message, &err, DBUS_TYPE_INT32, &gain,
+      DBUS_TYPE_INVALID);
+  if (ret) {
+    value  = am_modem_audio_set_gain(gain);
+  } else if (dbus_error_is_set(&err)) {
+    pa_log_error("am_dbus_server_handle_modem_audio_set_gain:%s\n", err.message);
+    dbus_error_free(&err);
+  }
+
+  *method_result = (gpointer) value;
+}
+
+static void am_dbus_server_handle_get_gain(am_dbus_server_t *server, DBusMessage *message, void **method_result)
+{
+  gint value = -1;
+  gint gain;
+  gint *arr;
+
+  value =  am_modem_audio_get_gain(&gain);
+  arr = g_malloc(3*sizeof(gint));
+  if (arr) {
+    arr[0] = value;
+    arr[1] = gain;
+    arr[2] = 0;
+  }
+
+	*method_result = (gpointer) arr;  /* TODO: free the arr in dbus-utils */
+}
 
diff -urN a/src/platform/mrst/audio-manager-dbus-mrst-service.h b/src/platform/mrst/audio-manager-dbus-mrst-service.h
--- a/src/platform/mrst/audio-manager-dbus-mrst-service.h	2009-05-11 06:08:18.000000000 +0800
+++ b/src/platform/mrst/audio-manager-dbus-mrst-service.h	2009-07-23 11:20:45.000000000 +0800
@@ -35,9 +35,14 @@
 #define AM_DBUS_INTERFACE_LPE "org.moblin.audiomanager.lpe"
 #define AM_DBUS_PATH_LPE "/org/moblin/audiomanager/lpe"
 
+#define AM_DBUS_INTERFACE_3G "org.moblin.audiomanager.modem"
+#define AM_DBUS_PATH_3G  "/org/moblin/audiomanager/modem"
+
+
 #define STREAM_DISABLE_LPE_DIRECT_RENDER_SIG "StreamDisableLPEDirectRender"
 #define STREAM_ENABLE_LPE_DIRECT_RENDER_SIG "StreamEnableLPEDirectRender"
 
 extern am_dbus_path_method_table_t am_lpe_method_table[];
+extern am_dbus_path_method_table_t am_3g_method_table[];
 
 #endif
diff -urN a/src/platform/mrst/intel_sst_ioctl.h b/src/platform/mrst/intel_sst_ioctl.h
--- a/src/platform/mrst/intel_sst_ioctl.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/platform/mrst/intel_sst_ioctl.h	2009-07-23 11:20:45.000000000 +0800
@@ -0,0 +1,348 @@
+#ifndef __INTEL_SST_IOCTL_H__
+#define __INTEL_SST_IOCTL_H__
+/*
+ *  intel_sst_ipc.h - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-09 	Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *  		Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file defines all sst ioctls
+ */
+
+/*codec and post/pre processing related info*/
+
+enum sst_codec_types {
+/*  AUDIO/MUSIC	CODEC Type Definitions */
+	SST_CODEC_TYPE_UNKNOWN = 0,
+	SST_CODEC_TYPE_PCM,	/* Pass through Audio codec */
+	SST_CODEC_TYPE_MP3,
+	SST_CODEC_TYPE_MP24,
+	SST_CODEC_TYPE_AAC,
+	SST_CODEC_TYPE_AACP,
+	SST_CODEC_TYPE_eAACP,
+	SST_CODEC_TYPE_WMA9,
+	SST_CODEC_TYPE_WMA10,
+	SST_CODEC_TYPE_WMA10P,
+	SST_CODEC_TYPE_RA,
+	SST_CODEC_TYPE_DDAC3,
+	SST_CODEC_TYPE_STEREO_TRUE_HD,
+	SST_CODEC_TYPE_STEREO_HD_PLUS,
+
+	/*  VOICE CODEC Type Definitions */
+	SST_CODEC_TYPE_VOICE_PCM = 0x21, /* Pass through voice codec */
+	SRC = 0x64,
+	MIXER = 0x65,
+	DOWN_MIXER = 0x66,
+	VOLUME_CONTROL = 0x67,
+	OEM1 = 0xC8,
+	OEM2 = 0xC9,
+};
+
+enum snd_sst_stream_ops {
+	STREAM_OPS_PLAYBACK = 0,	/* Decode */
+	STREAM_OPS_CAPTURE,		/* Encode */
+	STREAM_OPS_PLAYBACK_DRM,	/* Play Audio/Voice */
+	STREAM_OPS_PLAYBACK_ALERT,	/* Play Audio/Voice */
+	STREAM_OPS_CAPTURE_VOICE_CALL,	/* CSV Voice recording */
+};
+
+enum stream_type {
+	STREAM_TYPE_MUSIC = 1,
+	STREAM_TYPE_VOICE
+};
+
+/* Firmware Version info */
+struct snd_sst_fw_version {
+	u8 build;	/* build number*/
+	u8 minor;	/* minor number*/
+	u8 major;	/* major number*/
+	u8 type; /* build type*/
+};
+
+/* Port info structure */
+struct snd_sst_port_info {
+	u16 port_type;
+	u16  reserved;
+};
+
+/* Mixer info structure */
+struct snd_sst_mix_info {
+	u16 max_streams;
+	u16 reserved;
+};
+
+/* PCM Parameters */
+struct snd_pcm_params {
+	u16 codec;	/* codec type */
+	u8 num_chan;	/* 1=Mono, 2=Stereo	*/
+	u8 pcm_wd_sz;	/* 16/24 - bit*/
+	u32 brate;	/* Bitrate in bits per second */
+	u32 sfreq;	/* Sampling rate in Hz */
+	u16 frame_size;
+	u16 samples_per_frame;	/* Frame size num samples per frame */
+	u32 period_count; /* period elapsed time count, in samples,*/
+};
+
+/* MP3 Music Parameters Message */
+struct snd_mp3_params {
+	u16  codec;
+	u8   num_chan;	/* 1=Mono, 2=Stereo	*/
+	u8   pcm_wd_sz; /* 16/24 - bit*/
+	u32  brate; /* Use the hard coded value. */
+	u32  sfreq; /* Sampling freq eg. 8000, 441000, 48000 */
+	u8  crc_check; /* crc_check - disable (0) or enable (1) */
+	u8  op_align; /* op align 0- 16 bit, 1- MSB, 2 LSB*/
+	u16  reserved;	/* Unused */
+};
+
+#define AAC_BIT_STREAM_ADTS		0
+#define AAC_BIT_STREAM_ADIF		1
+#define AAC_BIT_STREAM_RAW		2
+
+/* AAC Music Parameters Message */
+struct snd_aac_params {
+	u16 codec;
+	u8 num_chan; /* 1=Mono, 2=Stereo*/
+	u8 pcm_wd_sz; /* 16/24 - bit*/
+	u32 brate;
+	u32 sfreq; /* Sampling freq eg. 8000, 441000, 48000 */
+	u32 aac_srate;	/* Plain AAC decoder operating sample rate */
+	u8 mpg_id; /* 0=MPEG-2, 1=MPEG-4 */
+	u8 bs_format; /* input bit stream format adts=0, adif=1, raw=2 */
+	u8 aac_profile; /* 0=Main Profile, 1=LC profile, 3=SSR profile */
+	u8 ext_chl; /* No.of external channels */
+	u8 aot; /* Audio object type. 1=Main , 2=LC , 3=SSR, 4=SBR*/
+	u8 op_align; /* output alignment 0=16 bit , 1=MSB, 2= LSB align */
+	u8 brate_type; /* 0=CBR, 1=VBR */
+	u8 crc_check; /* crc check 0= disable, 1=enable */
+	s8 bit_stream_format[8]; /* input bit stream format adts/adif/raw */
+};
+
+/* WMA Music Parameters Message */
+struct snd_wma_params {
+	u16  codec;
+	u8   num_chan;	/* 1=Mono, 2=Stereo	*/
+	u8   pcm_wd_sz;	/* 16/24 - bit*/
+	u32  brate; 	/* Use the hard coded value. */
+	u32  sfreq;	/* Sampling freq eg. 8000, 441000, 48000 */
+	u32  channel_mask;  /* Channel Mask */
+	u16  format_tag;	/* Format Tag */
+	u16  block_align;	/* packet size */
+	u16  wma_encode_opt;/* Encoder option */
+	u8 op_align;	/* op align 0- 16 bit, 1- MSB, 2 LSB*/
+	u8 reserved;	/* reserved */
+};
+
+/* Pre processing param structure */
+struct snd_prp_params {
+	u32  reserved;	/* No pre-processing defined yet */
+};
+
+/* Post processing Capability info structure */
+struct snd_sst_postproc_info {
+	u32 src_min;		/* Supported SRC Min sampling freq */
+	u32 src_max;		/* Supported SRC Max sampling freq */
+	u8  src;		/* 0=Not supported, 1=Supported */
+	u8  bass_boost;		/* 0=Not Supported, 1=Supported */
+	u8  stereo_widening;	/* 0=Not Supported, 1=Supported */
+	u8  volume_control; 	/* 0=Not Supported, 1=Supported */
+	s16 min_vol;		/* Minimum value of Volume in dB */
+	s16 max_vol;		/* Maximum value of Volume in dB */
+};
+
+/* pre processing Capability info structure */
+struct snd_sst_prp_info {
+	s16 min_vol;			/* Minimum value of Volume in dB */
+	s16 max_vol;			/* Maximum value of Volume in dB */
+	u8 volume_control; 		/* 0=Not Supported, 1=Supported */
+	u8 reserved1;			/* for 32 bit alignment */
+	u16 reserved2;			/* for 32 bit alignment */
+} __attribute__ ((packed));
+
+/* Firmware capabilities info */
+struct snd_sst_fw_info {
+	struct snd_sst_fw_version fw_version; /* Firmware version */
+	u8 audio_codecs_supported[8];	/* Codecs supported by FW */
+	u32 recommend_min_duration; /* Min duration for Low power Playback*/
+	u8 max_pcm_streams_supported; /*Max number of PCM streams supported */
+	u8 max_enc_streams_supported;	/*Max number of Encoded streams */
+	u16 reserved;			/* 32 bit alignment*/
+	struct snd_sst_postproc_info pop_info; /* Post processing capability*/
+	struct snd_sst_prp_info prp_info; /* pre_processing mod cap info */
+	struct snd_sst_port_info port_info[2]; /* Port info */
+	struct snd_sst_mix_info mix_info; 	/* Mixer info */
+	u32 min_input_buf; /*minmum i/p buffer for decode*/
+};
+
+/* Add the codec parameter structures for new codecs to be supported */
+#define CODEC_PARAM_STRUCTURES \
+	struct snd_pcm_params pcm_params; \
+	struct snd_mp3_params mp3_params; \
+	struct snd_aac_params aac_params; \
+	struct snd_wma_params wma_params;
+
+/* Pre and Post Processing param structures */
+#define PPP_PARAM_STRUCTURES \
+	struct snd_prp_params prp_params;
+
+/* Codec params struture */
+union  snd_sst_codec_params {
+	 CODEC_PARAM_STRUCTURES;
+};
+
+/* Pre-processing params struture */
+union snd_sst_ppp_params{
+	 PPP_PARAM_STRUCTURES;
+};
+
+struct snd_sst_stream_params {
+	union snd_sst_codec_params uc;
+} __attribute__ ((packed));
+
+struct snd_sst_params {
+	unsigned long 	result;
+	unsigned int 	stream_id;
+	enum sst_codec_types codec;
+	enum snd_sst_stream_ops	ops;
+	unsigned int	stream_type;
+	struct snd_sst_stream_params sparams;
+};
+
+/*ioctl related stuff here*/
+struct snd_sst_pmic_config {
+	u32  sfreq;                /* Sampling rate in Hz */
+	u16  num_chan;             /* Mono =1 or Stereo =2 */
+	u16  pcm_wd_sz;            /* Number of bits per sample */
+} __attribute__ ((packed));
+
+struct snd_sst_get_stream_params {
+	struct snd_sst_params codec_params;
+	struct snd_sst_pmic_config pcm_params;
+};
+
+enum snd_sst_target_type {
+	SND_SST_TARGET_PMIC = 1,
+	SND_SST_TARGET_OTHER,
+};
+
+enum snd_sst_port_action {
+	SND_SST_PORT_PREPARE = 1,
+	SND_SST_PORT_ACTIVATE,
+};
+
+/* Target selection per device structure */
+struct snd_sst_slot_info {
+	u8 mix_enable;		/* Mixer enable or disable */
+	u8 device_type;
+	u8 device_instance; 	/* 0, 1, 2 */
+	u16 slot[2];
+	struct snd_sst_pmic_config pcm_params;
+	enum snd_sst_target_type type;
+	s8 master;
+	enum snd_sst_port_action action;
+} __attribute__ ((packed));
+
+/* Target device list structure */
+struct snd_sst_target_device  {
+	u32 device_route;
+	struct snd_sst_slot_info devices[2];
+} __attribute__ ((packed));
+
+/* CSV Voice call routing structure */
+struct snd_sst_control_routing {
+	u8 control; 	/* 0=start, 1=Stop*/
+	u8 reserved[3];	/* Reserved- for 32 bit alignment */
+} __attribute__ ((packed));
+
+
+struct snd_sst_driver_info {
+	unsigned int version;	/* Version of the driver */
+	unsigned int active_pcm_streams;
+	unsigned int active_enc_streams;
+	unsigned int max_pcm_streams;
+	unsigned int max_enc_streams;
+	unsigned int buf_per_stream;
+};
+
+struct snd_sst_vol {
+	unsigned int	stream_id;
+	int		volume;
+	unsigned long	ramp_duration;
+	u32 ramp_type;		/* Ramp type, default=0 */
+};
+
+struct snd_sst_mute {
+	unsigned int	stream_id;
+	int		mute;
+};
+
+enum snd_sst_buff_type {
+	SST_BUF_USER = 1,
+	SST_BUF_MMAP,
+	SST_BUF_RAR,
+};
+
+struct snd_sst_buff_entry {
+	union {
+		void *user;
+		unsigned int offset;
+	} buffer;
+	unsigned int size;
+};
+
+struct snd_sst_buffs {
+	unsigned int entries;
+	enum snd_sst_buff_type type;
+	struct snd_sst_buff_entry *buff;
+};
+
+struct snd_sst_dbufs  {
+	struct snd_sst_buff_entry *ibufs;
+	struct snd_sst_buff_entry *obufs;
+	s8 force;
+};
+
+/*IOCTL defined here*/
+/*SST MMF IOCTLS only*/
+#define SNDRV_SST_STREAM_SET_PARAMS _IOR('L', 0x00, \
+					struct snd_sst_stream_params *)
+#define SNDRV_SST_STREAM_GET_PARAMS _IOWR('L', 0x01, \
+					struct snd_sst_get_stream_params *)
+#define SNDRV_SST_STREAM_GET_TSTAMP _IOWR('L', 0x02, unsigned long long *)
+#define	SNDRV_SST_STREAM_DECODE	_IOWR('L', 0x03, struct snd_sst_dbufs *)
+#define SNDRV_SST_STREAM_START	_IO('A', 0x42)
+#define SNDRV_SST_STREAM_DROP 	_IO('A', 0x43)
+#define SNDRV_SST_STREAM_DRAIN	_IO('A', 0x44)
+#define SNDRV_SST_STREAM_PAUSE 	_IOW('A', 0x45, int)
+#define SNDRV_SST_STREAM_RESUME _IO('A', 0x47)
+#define SNDRV_SST_MMAP_PLAY	_IOW('L', 0x05, struct snd_sst_buffs *)
+#define SNDRV_SST_MMAP_CAPTURE _IOW('L', 0x06, struct snd_sst_buffs *)
+/*SST common ioctls */
+#define SNDRV_SST_DRIVER_INFO	_IOR('L', 0x10, struct snd_sst_driver_info *)
+#define SNDRV_SST_SET_VOL	_IOW('L', 0x11, struct snd_sst_vol *)
+#define SNDRV_SST_GET_VOL	_IOW('L', 0x12, struct snd_sst_vol *)
+#define SNDRV_SST_MUTE		_IOW('L', 0x13, struct snd_sst_mute *)
+
+/*AM Ioctly only*/
+#define SNDRV_SST_FW_INFO	_IOR('L', 0x20,  struct snd_sst_fw_info *)
+#define SNDRV_SST_SET_TARGET_DEVICE _IOW('L', 0x21, \
+					struct snd_sst_target_device *)
+
+#endif /*__INTEL_SST_IOCTL_H__*/
diff -urN a/src/platform/mrst/modem_agent.c b/src/platform/mrst/modem_agent.c
--- a/src/platform/mrst/modem_agent.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/platform/mrst/modem_agent.c	2009-07-23 11:20:45.000000000 +0800
@@ -0,0 +1,300 @@
+#include "modem_agent.h"
+#include "config.h"
+#include "audio-manager-dbus-server-util.h"
+#include "audio-manager-dbus-generic-service.h"
+#include "module-mrst-specific.h"
+//#include "agent-dbus.h"
+
+#define MAX_NAME_LEN	(256)
+config_t config = {
+	.audio_dest = AM_DEST_DEFAULT,
+	.audio_active = FALSE,
+	.mute_status = FALSE,	/* TRUE indicates muted. Otherwise, unmuted */
+	.gain = 0,	/* output gain */
+
+	.tel_proxy = NULL,	/* Dbus proxy for telephony dbus */
+	.callback = NULL,
+	//DBusGConnection *tel_conn;
+
+};
+
+
+am_result_t am_register_modem_control_cb(const char *dbus_service, const char *dbus_path, const char *dbus_interface, const char *dbus_method)
+{
+	DBusGConnection *connection;
+	GError *error = NULL;
+
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+
+	if (!dbus_service || !dbus_path || !dbus_interface || !dbus_method) {
+		return AM_ERROR_INVALID_ARG;
+	}
+
+	g_type_init();
+
+	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+	if (connection == NULL)
+	{
+		g_printerr ("Failed to open connection to bus: %s\n", error->message);
+		g_error_free (error);
+		return AM_ERROR_DBUS;
+	}
+//	config.tel_conn = connection;	/* FIXME: if config.tel_conn is redudant */
+	
+	config.tel_proxy = dbus_g_proxy_new_for_name (connection, dbus_service, dbus_path, dbus_interface);
+	if (!config.tel_proxy) {
+		g_printerr ("Failed to new a proxy for name %s, path %s and interface %s\n", dbus_service,
+				dbus_path, dbus_interface);
+		return AM_ERROR_DBUS;
+	}
+
+	config.callback = g_strndup (dbus_method, MAX_NAME_LEN);
+	if (!config.callback) {
+		g_printerr ("Failed to duplicate method name\n");
+		am_unregister_modem_control_cb();
+		return AM_ERROR_MEMORY;
+	}
+
+	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+	if (connection == NULL)
+	{
+		g_printerr ("Failed to open connection to bus: %s\n", error->message);
+		g_error_free (error);
+		am_unregister_modem_control_cb();
+		return AM_ERROR_DBUS;
+	}
+
+	return AM_SUCCESS;
+}
+
+am_result_t am_unregister_modem_control_cb(void)
+{
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+
+	if (config.tel_proxy)
+		g_object_unref (config.tel_proxy);
+
+	if (config.callback)
+		g_free (config.callback);
+
+	config.tel_proxy = NULL;
+	config.callback = NULL;
+
+	return AM_SUCCESS;
+}
+
+static am_result_t am_modem_audio_control(am_dest_t dest, int output_volume)
+{
+	GError *error = NULL;
+	am_result_t res;
+
+	g_print ("Making DBUS callback: %s(dest = %d, output_volume = %d)\n",  __FUNCTION__, dest, output_volume);
+
+	if (!dbus_g_proxy_call (config.tel_proxy, config.callback, &error,
+				G_TYPE_INT, dest,
+				G_TYPE_INT, output_volume,
+				G_TYPE_INVALID,
+				G_TYPE_INT, &res,
+				G_TYPE_INVALID
+				))
+	{
+		/* Just do demonstrate remote exceptions versus regular GError */
+		if (error->domain == DBUS_GERROR && error->code == DBUS_GERROR_REMOTE_EXCEPTION)
+			g_printerr ("Caught remote method exception %s: %s",
+					dbus_g_error_get_name (error),
+					error->message);
+		else
+			g_printerr ("Error: %s\n", error->message);
+		g_error_free (error);
+		return AM_ERROR_DBUS;
+	}
+
+	return res;
+}
+
+typedef struct {
+	guint32 request_id;
+} request_t;
+
+
+
+static gboolean process_request_modem_audio(gpointer data)
+{
+	gint result = AM_SUCCESS;
+	
+	request_t *request = (request_t*) data;
+	g_print ("Handling request_modem_audio(request_id = %d)\n", request->request_id);
+
+	/* Do stuff before enabling modem audio */ 
+	
+	result = am_modem_audio_control(config.audio_dest, config.gain);		
+
+	/* Do more stuff after enabling modem audio */ 
+
+	/* All done now */
+	config.audio_active = TRUE;
+	g_print ("Sending signal: am_modem_audio_response(request_id = %d, result = %d)\n", request->request_id, result);
+	(void) emit_modem_audio_response_signal(request->request_id, result);
+	
+	g_free(request);
+	return FALSE;
+}
+
+am_result_t am_request_modem_audio(guint32 request_id)
+{
+	request_t *request;
+
+	g_print ("DBUS Call received: %s(request_id = %d)\n",  __FUNCTION__, request_id);
+
+	request = (request_t *) g_malloc(sizeof(request_t));
+	request->request_id = request_id;
+
+	g_timeout_add(0, process_request_modem_audio, request);
+	return AM_SUCCESS;
+}
+
+
+gboolean process_release_modem_audio(gpointer data);  /* for the sake of -Wall */
+gboolean process_release_modem_audio(gpointer data)
+{
+	gint result = AM_SUCCESS;
+	
+	request_t *request = (request_t*) data;
+	g_print ("Handling release_modem_audio(request_id = %d)\n", request->request_id);
+
+	/* Do stuff before disabling modem audio */ 
+	
+	/* Tell modem to disable it's audio */
+	result = am_modem_audio_control(AM_DEST_NONE, config.gain);		
+
+	/* Do more stuff after disabling modem audio */ 
+
+	/* All done now */
+	config.audio_active = FALSE;
+	g_print ("Sending signal: am_modem_audio_response(request_id = %d, result = %d)\n", request->request_id, result);
+	(void) emit_modem_audio_response_signal(request->request_id, result);
+	
+	g_free(request);
+	return FALSE;
+}
+
+am_result_t am_release_modem_audio(guint32 request_id)
+{
+	request_t *request;
+
+	g_print ("DBUS Call received: %s(request_id = %d)\n",  __FUNCTION__, request_id);
+
+	request = (request_t *) g_malloc(sizeof(request_t));
+	request->request_id = request_id;
+
+	g_timeout_add(0, process_release_modem_audio, request);
+	return AM_SUCCESS;
+}
+
+
+am_result_t am_modem_audio_set_dest(am_dest_t dest)
+{
+	am_dest_t old = config.audio_dest;
+
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+
+	config.audio_dest = dest;
+	if (old != dest)
+	{
+		if (config.audio_active)
+		{
+			/* Reroute modem audio */
+			/* Do stuff before rerouting modem audio */ 
+	
+			/* Tell modem to change it's audio config */
+			gint result = am_modem_audio_control(config.audio_dest, config.gain);		
+			if (result != AM_SUCCESS)
+			{
+				/* Do stuff to recover... */ 
+				return result;
+			}
+
+			/* Do stuff after rerouting modem audio */ 
+		}
+    (void) emit_modem_audio_changed_signal(config.audio_dest, config.mute_status, config.gain);
+	}
+
+	return AM_SUCCESS;
+}
+
+am_result_t am_modem_audio_get_dest(am_dest_t *dest)
+{
+	am_dest_t actual_dest;
+
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+	
+	actual_dest = config.audio_dest;
+	if (config.audio_dest == AM_DEST_DEFAULT) {
+		actual_dest = AM_DEST_EARPIECE;
+	}
+
+	*dest = actual_dest;
+
+	return AM_SUCCESS;
+}
+
+
+am_result_t am_modem_audio_set_mute(gboolean mute_input)
+{
+	gboolean old_mute = config.mute_status;
+
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+
+	config.mute_status = !!mute_input;
+	if (old_mute != config.mute_status)
+    emit_modem_audio_changed_signal(config.audio_dest, config.mute_status, config.gain);
+
+	return AM_SUCCESS;
+}
+
+am_result_t am_modem_audio_get_mute(gboolean *mute_status)
+{
+	g_print ("DBUS Call received: %s, mute:%d\n",  __FUNCTION__, config.mute_status);
+
+	*mute_status = config.mute_status;
+	return AM_SUCCESS;
+}
+
+am_result_t am_modem_audio_set_gain(int gain)
+{
+	int old_gain = config.gain;
+
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+
+	config.gain = gain;
+	if (old_gain != gain)
+	{
+		if (config.audio_active)
+		{
+			/* Change modem gain */
+
+			/* Do stuff before changing modem audio gain*/ 
+	
+			/* Tell modem to change it's audio config */
+			gint result = am_modem_audio_control(config.audio_dest, config.gain);		
+			if (result != AM_SUCCESS)
+			{
+				/* Do stuff to recover... */ 
+				return result;
+			}
+
+			/* Do stuff after changing modem audio gain*/ 
+		}
+    emit_modem_audio_changed_signal(config.audio_dest, config.mute_status, config.gain);
+	}
+
+	return AM_SUCCESS;
+}
+
+am_result_t am_modem_audio_get_gain(int *gain)
+{
+	g_print ("DBUS Call received: %s\n",  __FUNCTION__);
+
+	*gain = config.gain;
+	return AM_SUCCESS;
+}
diff -urN a/src/platform/mrst/modem_agent.h b/src/platform/mrst/modem_agent.h
--- a/src/platform/mrst/modem_agent.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/platform/mrst/modem_agent.h	2009-07-23 11:20:45.000000000 +0800
@@ -0,0 +1,62 @@
+#ifndef _MODEM_AGENT_H_
+#define _MODEM_AGENT_H_
+
+#include <dbus/dbus-glib.h>
+
+typedef enum am_result {
+	AM_SUCCESS = 0,
+	AM_ERROR_DEST_NOT_AVAILABLE,
+	AM_ERROR_DBUS,	/* errors related to dbus */
+	AM_ERROR_INVALID_ARG,
+	AM_ERROR_MEMORY,	/* errors related to memory allocation */
+	AM_ERROR_REJECTED,	/* audio request is rejected. Should we return a reason?*/
+} am_result_t;
+
+typedef enum {
+	AM_REJECT_DEST_NOT_AVAILABE,
+	AM_REJECT_PERMISSION_DENIED
+} reject_reason_t;
+
+typedef enum {
+	REQ_REJECTED,
+	REQ_GRANTED
+} req_result_t;
+
+typedef enum am_dest {
+	AM_DEST_NONE = 0,
+	AM_DEST_DEFAULT = -1,
+	AM_DEST_EARPIECE = (1 << 0),
+	AM_DEST_WIRED_HEADSET = (1 << 1),
+	AM_DEST_SPEAKERPHONE = (1 << 2),
+	AM_DEST_BT_HSP_HEADSET = (1 << 3),
+} am_dest_t;
+
+typedef struct {
+	am_dest_t audio_dest;
+	gboolean audio_active;
+	gboolean mute_status;	/* TRUE indicates muted, FALSE means unmuted */
+	int gain;	/* output gain */
+
+	DBusGProxy *tel_proxy;	/* Dbus proxy for telephony dbus */
+	gchar *callback;	/* Dbus method call name for callback */
+	//DBusGConnection *tel_conn;
+
+	DBusGProxy *pa_proxy;	/* Dbus proxy for PA */
+	//DBusGConnection *pa_conn;	/* maybe the same as tel_conn. It dosn't matter since it's shared object */
+} config_t;
+
+am_result_t am_unregister_modem_control_cb(void);
+am_result_t am_register_modem_control_cb(const char *dbus_service, const char *dbus_path, const char *dbus_interface, const char *dbus_method);
+am_result_t am_request_modem_audio(guint32 request_id);
+am_result_t am_release_modem_audio(guint32 request_id);
+am_result_t am_modem_audio_set_dest(am_dest_t dest);
+am_result_t am_modem_audio_get_dest(am_dest_t *dest);
+am_result_t am_modem_audio_set_mute(gboolean mute);
+am_result_t am_modem_audio_get_gain(int *gain);
+am_result_t am_modem_audio_set_gain(int gain);
+am_result_t am_modem_audio_get_mute(gboolean *mute);
+
+
+
+
+#endif
diff -urN a/src/platform/mrst/module-mrst-specific.c b/src/platform/mrst/module-mrst-specific.c
--- a/src/platform/mrst/module-mrst-specific.c	2009-07-23 10:31:23.000000000 +0800
+++ b/src/platform/mrst/module-mrst-specific.c	2009-07-23 11:20:45.000000000 +0800
@@ -73,6 +73,7 @@
 #include "audiomanager-device.h"
 #include "audio-manager-dbus-server-util.h"
 #include "audio-manager-dbus-mrst-service.h"
+#include "intel_sst_ioctl.h"
 
 PA_MODULE_AUTHOR("Long Bu");
 PA_MODULE_DESCRIPTION("Platform specific module for MRST");
@@ -82,26 +83,29 @@
                 "tsched=<enable system timer based scheduling mode?>");
 
 struct userdata {
-    pa_core *core;
-	am_core *am_core;
-    LibHalContext *context;
-    pa_dbus_connection *connection;
-    pa_hashmap *devices; /* Every entry is indexed twice in this table: by the udi we found the device with and by the originating device's udi */
-    const char *capability;
+  pa_core *core;
+  am_core *am_core;
+  LibHalContext *context;
+  pa_dbus_connection *connection;
+  pa_hashmap *devices; /* Every entry is indexed twice in this table: by the udi we found the device with and by the originating device's udi */
+  const char *capability;
 #ifdef HAVE_ALSA
-    pa_bool_t use_tsched;
+  pa_bool_t use_tsched;
 #endif
-	pa_mutex *mutex;
-	pa_hashmap *lpe_streams;
-	pa_sink* null_sink;
-
-	am_dbus_server_t *am_dbus_service_lpe;
-
-	pa_bluetooth_discovery *bt_discovery;	
-	pa_hook_slot* bt_event_slot;
-	pa_hook_slot* sink_unlink_slot;
-    pa_hashmap *bt_module_infos;  /* Entry to the module info of bluetooth device */
-    uint32_t bt_device_count;
+  pa_mutex *mutex;
+  pa_hashmap *lpe_streams;
+  pa_sink* null_sink;
+
+  am_dbus_server_t *am_dbus_service_lpe;
+  am_dbus_server_t *am_dbus_service_3g;
+
+  pa_bluetooth_discovery *bt_discovery;	
+  pa_hook_slot* bt_event_slot;
+  pa_hook_slot* sink_unlink_slot;
+  pa_hashmap *bt_module_infos;  /* Entry to the module info of bluetooth device */
+  uint32_t bt_device_count;
+
+  int lpe_ctl_fd; /* fd for lpe ctr */
 
 };
 
@@ -332,7 +336,7 @@
 	if (!d->sink && !d->source) {
 		args = pa_sprintf_malloc("device_id=%u name=%s card_name=%s tsched=%i sink_name=%s source_name=%s", card, strip_udi(originating_udi), card_name, (int) u->use_tsched, sink_name, source_name);
 
-		pa_log_debug("Loading module-alsa-card with arguments '%s'", args);
+		pa_log_warn("Loading module-alsa-card with arguments '%s'", args);
 		pa_log_error("Loading module-alsa-card with arguments '%s'", args);
 		m = pa_module_load(u->core, "module-alsa-card", args);
 		pa_xfree(args);
@@ -541,7 +545,7 @@
 
 		for (i = 0; i < n; i++) {
 			if (hal_device_add(u, udis[i]))
-				pa_log_debug("Not loaded device %s", udis[i]);
+				pa_log_warn("Not loaded device %s", udis[i]);
 			else
 			   	count++;
 		}
@@ -576,7 +580,7 @@
         goto finish;
 
     if (hal_device_add(u, udi))
-        pa_log_debug("Not loaded device %s", udi);
+        pa_log_warn("Not loaded device %s", udi);
 
 	pa_log_error("loaded device %s", udi);
 finish:
@@ -859,7 +863,7 @@
 	}
 
 	/*load module for device*/
-	args = pa_sprintf_malloc("sink_name=\"%s.output\" source_name=\"%s.output\" profile=\"%s\" path=\"%s\"",
+	args = pa_sprintf_malloc("sink_name=\"%s.output\" source_name=\"%s.input\" profile=\"%s\" path=\"%s\"",
 			d->name, d->name, bt_profile_names[dev_priv->profile], dev_priv->path);
 	m = pa_module_load(u->core, "module-bluetooth-device", args);
 	pa_xfree(args);
@@ -1276,7 +1280,7 @@
 	for(p = path; p && p+1; p = strchr(p+1,'/')){
 		if(!strncmp(p+1, "hci", 3)){
 			p_next = strchr(p+1, '/');
-			return p_next==NULL? NULL: pa_xstrndup(p,p_next-p);
+			return p_next==NULL? NULL: pa_xstrndup(p+1,p_next-p-1);
 		}
 	}
 	return NULL;
@@ -1311,6 +1315,7 @@
 	char* hci_interface;
 	hci_interface = bt_get_interface_from_path(path);
 	di.dev_id = atoi(hci_interface+3); //skip "hci"
+	pa_log_error("BT device on HCI%d", di.dev_id);
 	pa_xfree(hci_interface);
     if ((ctl = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI)) < 0) {
     	pa_log_error("Can't open HCI socket.");
@@ -1499,7 +1504,7 @@
 			 	pa_log_error( "unregister device name: %s",device_name);
 				pa_xfree(device_name);
 			 }					 
-            pa_log_debug("Unloading module for %s", d->path);
+            pa_log_warn("Unloading module for %s", d->path);
             pa_module_unload_request_by_index(u->core, mi->module, TRUE);
 
             pa_hashmap_remove(u->bt_module_infos, mi->path);
@@ -1524,141 +1529,155 @@
 }
 
 int pa__init(pa_module*m) {
-    DBusError error;
-    int n = 0;
-    pa_modargs *ma;
-    const char *api;
-    pa_module* m_null_sink;
-    char* load_args;
-	struct userdata *u = NULL;
-
-    pa_assert(m);
-
-    dbus_error_init(&error);
-
-    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
-        pa_log("Failed to parse module arguments");
-        goto fail;
-    }
+  DBusError error;
+  int n = 0;
+  pa_modargs *ma;
+  const char *api;
+  pa_module* m_null_sink;
+  char* load_args;
+  struct userdata *u = NULL;
+
+  pa_assert(m);
+
+  dbus_error_init(&error);
+
+  if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+    pa_log("Failed to parse module arguments");
+    goto fail;
+  }
 
-	pa_log_error("line:%d\n", __LINE__);
-	mixer_utils_init();
-    g_u = m->userdata = u = pa_xnew(struct userdata, 1);
-    u->core = m->core;
-	u->am_core = pa_hashmap_get(u->core->namereg, AM_CORE);
-	pa_assert(u->am_core);
-	u->am_core->device_migrate = mrst_device_migrate;
-
-    u->context = NULL;
-    u->connection = NULL;
-    u->devices = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
-    u->lpe_streams = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
-    u->capability = NULL;
-//	u->lpe_obj = create_lpe_object();
+  pa_log_error("line:%d\n", __LINE__);
+  mixer_utils_init();
+  g_u = m->userdata = u = pa_xnew(struct userdata, 1);
+  u->core = m->core;
+  u->am_core = pa_hashmap_get(u->core->namereg, AM_CORE);
+  pa_assert(u->am_core);
+  u->am_core->device_migrate = mrst_device_migrate;
+
+  u->context = NULL;
+  u->connection = NULL;
+  u->devices = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
+  u->lpe_streams = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
+  u->capability = NULL;
+  //	u->lpe_obj = create_lpe_object();
 
-	u->mutex = pa_mutex_new(TRUE, FALSE);
-	pa_log_error("line:%d\n", __LINE__);
+  u->mutex = pa_mutex_new(TRUE, FALSE);
+  pa_log_error("line:%d\n", __LINE__);
 
 #ifdef HAVE_ALSA
-    u->use_tsched = TRUE;
+  u->use_tsched = TRUE;
 
-    if (pa_modargs_get_value_boolean(ma, "tsched", &u->use_tsched) < 0) {
-        pa_log("Failed to parse tsched argument.");
-        goto fail;
-    }
+  if (pa_modargs_get_value_boolean(ma, "tsched", &u->use_tsched) < 0) {
+    pa_log("Failed to parse tsched argument.");
+    goto fail;
+  }
 
-    api = pa_modargs_get_value(ma, "api", "alsa");
+  api = pa_modargs_get_value(ma, "api", "alsa");
 
-    if (pa_streq(api, "alsa"))
-        u->capability = CAPABILITY_ALSA;
+  if (pa_streq(api, "alsa"))
+    u->capability = CAPABILITY_ALSA;
 #else
-    api = pa_modargs_get_value(ma, "api", "oss");
+  api = pa_modargs_get_value(ma, "api", "oss");
 #endif
 
-	pa_log_error("line:%d\n", __LINE__);
-
-    if (!u->capability) {
-        pa_log_error("Invalid API specification.");
-        goto fail;
-    }
+  pa_log_error("line:%d\n", __LINE__);
 
-    if (!(u->connection = pa_dbus_bus_get(m->core, DBUS_BUS_SYSTEM, &error)) || dbus_error_is_set(&error)) {
-        pa_log_error("Unable to contact DBUS system bus: %s: %s", error.name, error.message);
-        goto fail;
-    }
+  if (!u->capability) {
+    pa_log_error("Invalid API specification.");
+    goto fail;
+  }
 
-	pa_log_error("line:%d\n", __LINE__);
-    if (!(u->context = hal_context_new(pa_dbus_connection_get(u->connection)))) {
-        /* pa_hal_context_new() logs appropriate errors */
-        goto fail;
-    }
-	pa_log_error("line:%d\n", __LINE__);
-    n = hal_device_add_all(u);
-	pa_log_error("line:%d\n", __LINE__);
-
-    libhal_ctx_set_user_data(u->context, u);
-    libhal_ctx_set_device_added(u->context, device_added_cb);
-    libhal_ctx_set_device_removed(u->context, device_removed_cb);
-    libhal_ctx_set_device_new_capability(u->context, new_capability_cb);
-    libhal_ctx_set_device_lost_capability(u->context, lost_capability_cb);
-
-	pa_log_error("line:%d\n", __LINE__);
-    if (!libhal_device_property_watch_all(u->context, &error)) {
-        pa_log_error("Error monitoring device list: %s: %s", error.name, error.message);
-        goto fail;
-    }
-    
-	u->am_dbus_service_lpe = am_dbus_server_new(u->am_core->am_dbus_connection);
-    //You can set userdata to your preferred data, but ensure inteprete them correctly inside your handlers.
-    u->am_dbus_service_lpe->userdata = u;
-    am_dbus_server_add_path_methods(u->am_core->am_dbus_connection, AM_DBUS_PATH_LPE, am_lpe_method_table, u->am_dbus_service_lpe);
-
-	/*Bluetooth discover init*/
-  	u->bt_module_infos = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
-   	if (!(u->bt_discovery = pa_bluetooth_discovery_get(u->core)))
-        goto fail;
+  if (!(u->connection = pa_dbus_bus_get(m->core, DBUS_BUS_SYSTEM, &error)) || dbus_error_is_set(&error)) {
+    pa_log_error("Unable to contact DBUS system bus: %s: %s", error.name, error.message);
+    goto fail;
+  }
 
-     u->bt_event_slot= pa_hook_connect(pa_bluetooth_discovery_hook(u->bt_discovery), PA_HOOK_NORMAL, (pa_hook_cb_t) bt_device_event_cb, u);
-	u->bt_device_count = 0;
+  pa_log_error("line:%d\n", __LINE__);
+  if (!(u->context = hal_context_new(pa_dbus_connection_get(u->connection)))) {
+    /* pa_hal_context_new() logs appropriate errors */
+    goto fail;
+  }
+  pa_log_error("line:%d\n", __LINE__);
+  n = hal_device_add_all(u);
+  pa_log_error("line:%d\n", __LINE__);
+
+  libhal_ctx_set_user_data(u->context, u);
+  libhal_ctx_set_device_added(u->context, device_added_cb);
+  libhal_ctx_set_device_removed(u->context, device_removed_cb);
+  libhal_ctx_set_device_new_capability(u->context, new_capability_cb);
+  libhal_ctx_set_device_lost_capability(u->context, lost_capability_cb);
+
+  pa_log_error("line:%d\n", __LINE__);
+  if (!libhal_device_property_watch_all(u->context, &error)) {
+    pa_log_error("Error monitoring device list: %s: %s", error.name, error.message);
+    goto fail;
+  }
 
-	u->sink_unlink_slot= pa_hook_connect(&(u->core->hooks[PA_CORE_HOOK_SINK_UNLINK]), PA_HOOK_NORMAL, (pa_hook_cb_t) sink_unlink_cb, u);
-	/***load null sink***/
-	load_args = pa_sprintf_malloc("sink_name=\"%s\" ", MRST_NULL_SINK_NAME);
-	m_null_sink = pa_module_load(u->core, "module-null-sink",load_args);
-	u->null_sink = pa_namereg_get(u->core, MRST_NULL_SINK_NAME, PA_NAMEREG_SINK);
-	pa_assert(u->null_sink);
+  u->am_dbus_service_lpe = am_dbus_server_new(u->am_core->am_dbus_connection);
+  //You can set userdata to your preferred data, but ensure inteprete them correctly inside your handlers.
+  u->am_dbus_service_lpe->userdata = u;
+  am_dbus_server_add_path_methods(u->am_core->am_dbus_connection, AM_DBUS_PATH_LPE, am_lpe_method_table, u->am_dbus_service_lpe);
+
+  u->am_dbus_service_3g = am_dbus_server_new(u->am_core->am_dbus_connection);
+  //You can set userdata to your preferred data, but ensure inteprete them correctly inside your handlers.
+  u->am_dbus_service_3g->userdata = u;
+  am_dbus_server_add_path_methods(u->am_core->am_dbus_connection, AM_DBUS_PATH_3G, am_3g_method_table, u->am_dbus_service_3g);
+
+
+  /*Bluetooth discover init*/
+  u->bt_module_infos = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
+  if (!(u->bt_discovery = pa_bluetooth_discovery_get(u->core)))
+    goto fail;
+
+  u->bt_event_slot= pa_hook_connect(pa_bluetooth_discovery_hook(u->bt_discovery), PA_HOOK_NORMAL, (pa_hook_cb_t) bt_device_event_cb, u);
+  u->bt_device_count = 0;
+
+  u->sink_unlink_slot= pa_hook_connect(&(u->core->hooks[PA_CORE_HOOK_SINK_UNLINK]), PA_HOOK_NORMAL, (pa_hook_cb_t) sink_unlink_cb, u);
+  /***load null sink***/
+  load_args = pa_sprintf_malloc("sink_name=\"%s\" ", MRST_NULL_SINK_NAME);
+  m_null_sink = pa_module_load(u->core, "module-null-sink",load_args);
+  u->null_sink = pa_namereg_get(u->core, MRST_NULL_SINK_NAME, PA_NAMEREG_SINK);
+  pa_assert(u->null_sink);
 #if 0
-    if (!dbus_connection_add_filter(pa_dbus_connection_get(u->connection), filter_cb, u, NULL)) {
-        pa_log_error("Failed to add filter function");
-        goto fail;
-    }
+  if (!dbus_connection_add_filter(pa_dbus_connection_get(u->connection), filter_cb, u, NULL)) {
+    pa_log_error("Failed to add filter function");
+    goto fail;
+  }
 
-    if (pa_dbus_add_matches(
-                pa_dbus_connection_get(u->connection), &error,
-                "type='signal',sender='org.freedesktop.Hal',interface='org.freedesktop.Hal.Device.AccessControl',member='ACLAdded'",
-                "type='signal',sender='org.freedesktop.Hal',interface='org.freedesktop.Hal.Device.AccessControl',member='ACLRemoved'",
-                "type='signal',interface='org.pulseaudio.Server',member='DirtyGiveUpMessage'", NULL) < 0) {
-        pa_log_error("Unable to subscribe to HAL ACL signals: %s: %s", error.name, error.message);
-        goto fail;
-    }
+  if (pa_dbus_add_matches(
+        pa_dbus_connection_get(u->connection), &error,
+        "type='signal',sender='org.freedesktop.Hal',interface='org.freedesktop.Hal.Device.AccessControl',member='ACLAdded'",
+        "type='signal',sender='org.freedesktop.Hal',interface='org.freedesktop.Hal.Device.AccessControl',member='ACLRemoved'",
+        "type='signal',interface='org.pulseaudio.Server',member='DirtyGiveUpMessage'", NULL) < 0) {
+    pa_log_error("Unable to subscribe to HAL ACL signals: %s: %s", error.name, error.message);
+    goto fail;
+  }
 #endif
-		
-    pa_log_info("Loaded %i modules.", n);
-	pa_log_error("line:%d\n", __LINE__);
 
-    pa_modargs_free(ma);
+  u->lpe_ctl_fd = open("/dev/lpe_ctl", O_RDWR);
+  if (u->lpe_ctl_fd < 0) {
+    /* don't return false for now. since device driver
+     * is not ready and this open will always be failing 
+     */
+    pa_log_error("open /dev/lpe_ctl error\n");
+  }
 
-    return 0;
+
+  pa_log_info("Loaded %i modules.", n);
+
+  pa_modargs_free(ma);
+
+  return 0;
 
 fail:
-    if (ma)
-        pa_modargs_free(ma);
+  if (ma)
+    pa_modargs_free(ma);
 
-	pa_mutex_free(u->mutex);
-    dbus_error_free(&error);
-    pa__done(m);
+  pa_mutex_free(u->mutex);
+  dbus_error_free(&error);
+  pa__done(m);
 
-    return -1;
+  return -1;
 }
 
 void pa__done(pa_module *m) {
@@ -1669,6 +1688,9 @@
     if (!(u = m->userdata))
         return;
 
+    if (u->lpe_ctl_fd)
+      close(u->lpe_ctl_fd);
+
     if (u->context)
         hal_context_free(u->context);
     am_dbus_server_remove_path_methods(u->am_dbus_service_lpe->connection, AM_DBUS_PATH_LPE);
@@ -1745,16 +1767,69 @@
     pa_xfree(u);
 }
 
+static int lpe_hw_get_volume(am_stream *s, int *vol)
+{
+  lpe_stream_priv_t *lpe_priv;
+  struct snd_sst_vol lpe_vol;
+  int ret;
+  if (g_u->lpe_ctl_fd < 0) {
+    pa_log_error("lpe_hw_get_volume: no lpe_ctl device file descriptor\n");
+    return -1;
+  }
+
+  lpe_priv = (lpe_stream_priv_t *)(s->priv);
+	if (!lpe_priv) {
+		pa_log_error("lpe_hw_get_volume: no lpe private data\n");
+		return -1;
+	}
+
+  lpe_vol.stream_id =  lpe_priv->lpe_stream_id;
+  ret = ioctl(g_u->lpe_ctl_fd, SNDRV_SST_GET_VOL, &lpe_vol);
+  if (ret >= 0)
+    *vol = lpe_vol.volume;
+
+  return ret;
+}
+
 static int lpe_stream_get_volume(am_stream *s)
 {
-	pa_log_error("lpe_stream_get_volume not implemented yet\n");
-	return 0;
+  int vol;
+  pa_log_error("lpe_stream_get_volume not implemented yet\n");
+  if (lpe_hw_get_volume(s, &vol) < 0)
+    return -1;
+  return vol;
 }
 
 static void lpe_hw_set_volume(guint lpe_stream_id, int gain)
 {
-    /* TODO: translate gain into LPE's gain*/
-	pa_log_error("lpe_hw_set_volume not implemented yet\n");
+  lpe_stream_priv_t *lpe_priv;
+  am_stream *s = NULL;
+  guint am_stream_id;
+  struct snd_sst_vol lpe_vol;
+
+
+  int ret;
+  if (g_u->lpe_ctl_fd < 0) {
+    pa_log_error("lpe_hw_get_volume: no lpe_ctl device file descriptor\n");
+    return;
+  }
+
+	am_stream_id = (guint)pa_hashmap_get(g_u->lpe_streams, (void *)lpe_stream_id);
+  s = g_u->am_core->get_stream(g_u->am_core, am_stream_id);
+  pa_assert(s);
+  lpe_priv = (lpe_stream_priv_t *)(s->priv);
+  if (!lpe_priv) {
+    pa_log_error("lpe_hw_get_volume: no lpe private data\n");
+    return;
+  }
+
+  bzero(&lpe_vol, sizeof(lpe_vol));
+  lpe_vol.stream_id =  lpe_priv->lpe_stream_id;
+  lpe_vol.volume = gain;
+  ret = ioctl(g_u->lpe_ctl_fd, SNDRV_SST_SET_VOL, &lpe_vol);
+  if (ret < 0)
+    pa_log_error("lpw_hw_set_volume: ioctl SNDRV_SST_SET_VOL fail\n");
+
 }
 
 static int lpe_stream_set_volume(am_stream *s, int gain)
@@ -1881,3 +1956,19 @@
 {
 	return 0;
 }
+
+
+/* Public methods */
+void emit_modem_audio_changed_signal(gint am_dest, gboolean mute, gint gain)
+{
+	emit_signal_on_path_interface(AM_DBUS_PATH_3G, AM_DBUS_INTERFACE_3G, g_u->am_core->am_dbus_connection, "ModemAudioChanged", DBUS_TYPE_INT32, am_dest,
+      DBUS_TYPE_INT32, DBUS_TYPE_INT32, mute, DBUS_TYPE_INT32, gain, DBUS_TYPE_INVALID);
+}
+
+/* Public methods */
+void emit_modem_audio_response_signal(guint request_id, gint result)
+{
+	emit_signal_on_path_interface(AM_DBUS_PATH_3G, AM_DBUS_INTERFACE_3G, g_u->am_core->am_dbus_connection, "ModemAudioResponse", DBUS_TYPE_UINT32, request_id, DBUS_TYPE_INT32, result, DBUS_TYPE_INVALID);
+}
+
+
diff -urN a/src/platform/mrst/module-mrst-specific.h b/src/platform/mrst/module-mrst-specific.h
--- a/src/platform/mrst/module-mrst-specific.h	2009-05-11 06:08:18.000000000 +0800
+++ b/src/platform/mrst/module-mrst-specific.h	2009-07-23 11:20:45.000000000 +0800
@@ -29,6 +29,14 @@
 #define _MODULE_MRST_SPECIFIC_H_
 #include <glib.h>
 
+typedef unsigned char u8;
+typedef unsigned int u32;
+typedef unsigned short u16;
+typedef char s8;
+typedef int s32;
+typedef short s16;
+
+
 #define PA_PROP_AM_PRIVATE						"am.private"
 
 gint lpe_stream_register(guint lpe_stream_id, char *media_role, char *lpe_stream_name, char *binary_name);
@@ -37,4 +45,7 @@
 gint lpe_stream_notify_pause(guint stream_id);
 gint lpe_stream_notify_resume(guint stream_id);
 
+void emit_modem_audio_changed_signal(gint am_dest, gboolean mute, gint gain);
+void emit_modem_audio_response_signal(guint request_id, gint result);
+
 #endif
diff -urN a/src/policy-actions.c b/src/policy-actions.c
--- a/src/policy-actions.c	2009-05-11 06:08:18.000000000 +0800
+++ b/src/policy-actions.c	2009-07-23 11:20:45.000000000 +0800
@@ -114,6 +114,7 @@
     /* recover header is possible*/
     if ( s1->attenuation_set ) {
 
+        pa_log_debug("restore attenuation to %d\n", s1->previous_gain);
         s1->set_volume(s1, s1->previous_gain);
         s1->attenuation_set = FALSE;
     }
@@ -123,6 +124,7 @@
     while (s1) {
         if (s1->attenuation >= 0 && !s1->attenuation_set) {
             s1->previous_gain = s1->get_volume(s1);
+            pa_log_debug("set attenuation to %d\n", s1->attenuation);
             s1->set_volume(s1, s1->attenuation);
             s1->attenuation_set = TRUE;
         }
diff -urN a/src/policy.c b/src/policy.c
--- a/src/policy.c	2009-07-23 10:31:30.000000000 +0800
+++ b/src/policy.c	2009-07-23 11:20:45.000000000 +0800
@@ -653,7 +653,7 @@
     {
         pa_strip_nl(line);
         am_parse_conf_line(line, &bktstate, &objtype);
-        pa_log_debug("%s\n", line);
+        pa_log_warn("%s\n", line);
     }
 
     am_conf.devices = &devices;
